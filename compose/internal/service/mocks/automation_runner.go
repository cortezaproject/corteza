// Code generated by MockGen. DO NOT EDIT.
// Source: compose/internal/service/automation_runner.go

// Package service_mocks is a generated GoMock package.
package service_mocks

import (
	context "context"
	automation "github.com/cortezaproject/corteza-server/pkg/automation"
	gomock "github.com/golang/mock/gomock"
	reflect "reflect"
)

// MockautomationScriptsFinder is a mock of automationScriptsFinder interface
type MockautomationScriptsFinder struct {
	ctrl     *gomock.Controller
	recorder *MockautomationScriptsFinderMockRecorder
}

// MockautomationScriptsFinderMockRecorder is the mock recorder for MockautomationScriptsFinder
type MockautomationScriptsFinderMockRecorder struct {
	mock *MockautomationScriptsFinder
}

// NewMockautomationScriptsFinder creates a new mock instance
func NewMockautomationScriptsFinder(ctrl *gomock.Controller) *MockautomationScriptsFinder {
	mock := &MockautomationScriptsFinder{ctrl: ctrl}
	mock.recorder = &MockautomationScriptsFinderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockautomationScriptsFinder) EXPECT() *MockautomationScriptsFinderMockRecorder {
	return m.recorder
}

// Watch mocks base method
func (m *MockautomationScriptsFinder) Watch(ctx context.Context) {
	m.ctrl.Call(m, "Watch", ctx)
}

// Watch indicates an expected call of Watch
func (mr *MockautomationScriptsFinderMockRecorder) Watch(ctx interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Watch", reflect.TypeOf((*MockautomationScriptsFinder)(nil).Watch), ctx)
}

// FindRunnableScripts mocks base method
func (m *MockautomationScriptsFinder) FindRunnableScripts(resource, event string, cc ...automation.TriggerConditionChecker) automation.ScriptSet {
	varargs := []interface{}{resource, event}
	for _, a := range cc {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "FindRunnableScripts", varargs...)
	ret0, _ := ret[0].(automation.ScriptSet)
	return ret0
}

// FindRunnableScripts indicates an expected call of FindRunnableScripts
func (mr *MockautomationScriptsFinderMockRecorder) FindRunnableScripts(resource, event interface{}, cc ...interface{}) *gomock.Call {
	varargs := append([]interface{}{resource, event}, cc...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindRunnableScripts", reflect.TypeOf((*MockautomationScriptsFinder)(nil).FindRunnableScripts), varargs...)
}

// MockautomationRunnerAccessControler is a mock of automationRunnerAccessControler interface
type MockautomationRunnerAccessControler struct {
	ctrl     *gomock.Controller
	recorder *MockautomationRunnerAccessControlerMockRecorder
}

// MockautomationRunnerAccessControlerMockRecorder is the mock recorder for MockautomationRunnerAccessControler
type MockautomationRunnerAccessControlerMockRecorder struct {
	mock *MockautomationRunnerAccessControler
}

// NewMockautomationRunnerAccessControler creates a new mock instance
func NewMockautomationRunnerAccessControler(ctrl *gomock.Controller) *MockautomationRunnerAccessControler {
	mock := &MockautomationRunnerAccessControler{ctrl: ctrl}
	mock.recorder = &MockautomationRunnerAccessControlerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockautomationRunnerAccessControler) EXPECT() *MockautomationRunnerAccessControlerMockRecorder {
	return m.recorder
}

// CanRunAutomationTrigger mocks base method
func (m *MockautomationRunnerAccessControler) CanRunAutomationTrigger(ctx context.Context, r *automation.Trigger) bool {
	ret := m.ctrl.Call(m, "CanRunAutomationTrigger", ctx, r)
	ret0, _ := ret[0].(bool)
	return ret0
}

// CanRunAutomationTrigger indicates an expected call of CanRunAutomationTrigger
func (mr *MockautomationRunnerAccessControlerMockRecorder) CanRunAutomationTrigger(ctx, r interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CanRunAutomationTrigger", reflect.TypeOf((*MockautomationRunnerAccessControler)(nil).CanRunAutomationTrigger), ctx, r)
}
