package rdbms

// Handles record values
//
// This file IS NOT autogenerated like most of other store handlers
// because of the specificities that are required for compose record (value) store handling
//
// Main difference is record (value) searching and storage is based on record module settings.

import (
	"context"
	"database/sql"
	"fmt"
	"github.com/Masterminds/squirrel"
	"github.com/cortezaproject/corteza-server/compose/types"
	"github.com/cortezaproject/corteza-server/pkg/ql"
	"github.com/cortezaproject/corteza-server/pkg/rh"
	"github.com/cortezaproject/corteza-server/store"
	"github.com/jmoiron/sqlx"
	"strings"
)

// SearchComposeRecords returns all matching rows
//
// This function calls convertComposeRecordFilter with the given
// types.RecordFilter and expects to receive a working squirrel.SelectBuilder
func (s Store) SearchComposeRecords(ctx context.Context, m *types.Module, f types.RecordFilter) (types.RecordSet, types.RecordFilter, error) {
	q, err := s.convertComposeRecordFilter(m, f)
	if err != nil {
		return nil, f, err
	}

	q = ApplyPaging(q, f.PageFilter)

	cap := f.PerPage
	if cap == 0 {
		cap = DefaultSliceCapacity
	}

	var (
		set = make([]*types.Record, 0, cap)
		res *types.Record
	)

	return set, f, func() error {
		if f.Count, err = Count(ctx, s.db, q); err != nil || f.Count == 0 {
			return err
		}
		rows, err := s.Query(ctx, q)
		if err != nil {
			return err
		}

		defer rows.Close()
		for rows.Next() {
			if res, err = s.scanComposeRecord(rows, rows.Err()); err != nil {
				return err
			}

			set = append(set, res)
		}

		return nil
	}()
}

func (s Store) convertComposeRecordFilter(m *types.Module, f types.RecordFilter) (query squirrel.SelectBuilder, err error) {
	var (
		joinedFields  = []string{}
		alreadyJoined = func(f string) bool {
			for _, a := range joinedFields {
				if a == f {
					return true
				}
			}

			joinedFields = append(joinedFields, f)
			return false
		}

		identResolver = func(i ql.Ident) (ql.Ident, error) {
			var is bool
			if i.Value, is = isRealRecordCol(i.Value); is {
				i.Value += " "
				return i, nil
			}

			if !m.Fields.HasName(i.Value) {
				return i, fmt.Errorf("unknown field %q", i.Value)
			}

			if !alreadyJoined(i.Value) {
				query = query.LeftJoin(fmt.Sprintf(
					"compose_record_value AS rv_%s ON (rv_%s.record_id = crc.id AND rv_%s.name = ? AND rv_%s.deleted_at IS NULL)",
					i.Value, i.Value, i.Value, i.Value,
				), i.Value)
			}

			field := m.Fields.FindByName(i.Value)

			switch true {
			case field.IsBoolean():
				i.Value = fmt.Sprintf("(rv_%s.value NOT IN ('', '0', 'false', 'f',  'FALSE', 'F', false))", i.Value)
			case field.IsNumeric():
				i.Value = fmt.Sprintf("CAST(rv_%s.value AS SIGNED)", i.Value)
			case field.IsDateTime():
				i.Value = fmt.Sprintf("CAST(rv_%s.value AS DATETIME)", i.Value)
			case field.IsRef():
				i.Value = fmt.Sprintf("rv_%s.ref ", i.Value)
			default:
				i.Value = fmt.Sprintf("rv_%s.value ", i.Value)
			}

			return i, nil
		}
	)

	// Create query for fetching and counting records.
	query = s.QueryComposeRecords(m).
		Where("crc.module_id = ?", m.ID).
		Where("crc.rel_namespace = ?", m.NamespaceID)

	// Inc/exclude deleted records according to filter settings
	query = rh.FilterNullByState(query, "crc.deleted_at", f.Deleted)

	// Parse filters.
	if f.Query != "" {
		var (
			// Filter parser
			fp = ql.NewParser()

			// Filter node
			fn ql.ASTNode
		)

		// Resolve all identifiers found in the query
		// into their table/column counterparts
		fp.OnIdent = identResolver

		if fn, err = fp.ParseExpression(f.Query); err != nil {
			return
		} else if filterSql, filterArgs, err := fn.ToSql(); err != nil {
			return query, err
		} else {
			query = query.Where("("+filterSql+")", filterArgs...)
		}
	}

	if f.Sort != "" {
		var (
			// Sort parser
			sp = ql.NewParser()

			// Sort columns
			sc ql.Columns
		)

		// Resolve all identifiers found in sort
		// into their table/column counterparts
		sp.OnIdent = identResolver

		if sc, err = sp.ParseColumns(f.Sort); err != nil {
			return
		}

		query = query.OrderBy(sc.Strings()...)
	}

	return
}

// LookupComposeRecordByID searches for compose page by ID
//
// It returns compose page even if deleted
func (s Store) LookupComposeRecordByID(ctx context.Context, m *types.Module, id uint64) (*types.Record, error) {
	return s.ComposeRecordLookup(ctx, m, squirrel.Eq{
		"crc.id": id,
	})
}

// CreateComposeRecord creates one or more rows in compose_record table
func (s Store) CreateComposeRecord(ctx context.Context, m *types.Module, rr ...*types.Record) error {
	if len(rr) == 0 {
		return nil
	}

	return Tx(ctx, s.db, s.config, nil, func(db *sqlx.Tx) (err error) {
		for _, res := range rr {
			err = ExecuteSqlizer(ctx, s.DB(), s.Insert(s.ComposeRecordTable(m)).SetMap(s.ComposeRecordEnc(res)))
			if err != nil {
				return err
			}
		}

		return nil
	})
}

// CreateComposeRecordValue creates one or more rows in compose_record_value table
//
// @this can probbably be merged with CreateComposeRecord
func (s Store) CreateComposeRecordValue(ctx context.Context, m *types.Module, rr ...*types.RecordValue) error {
	if len(rr) == 0 {
		return nil
	}

	return Tx(ctx, s.db, s.config, nil, func(db *sqlx.Tx) (err error) {
		for _, res := range rr {
			err = ExecuteSqlizer(ctx, s.DB(), s.Insert(s.ComposeRecordValueTable(m)).SetMap(s.ComposeRecordValueEnc(res)))
			if err != nil {
				return err
			}
		}

		return nil
	})
}

// UpdateComposeRecord updates one or more existing rows in compose_record
func (s Store) UpdateComposeRecord(ctx context.Context, m *types.Module, rr ...*types.Record) error {
	return s.PartialUpdateComposeRecord(ctx, m, nil, rr...)
}

// UpdateComposeRecordValue updates one or more existing rows in compose_record_value
//
// @todo this can probably be merged with UpdateComposeRecord
func (s Store) UpdateComposeRecordValue(ctx context.Context, m *types.Module, rr ...*types.RecordValue) error {
	return s.PartialUpdateComposeRecordValue(ctx, m, rr...)
}

// PartialUpdateComposeRecord updates one or more existing rows in compose_record
//
// It wraps the update into transaction and can perform partial update by providing list of updatable columns
func (s Store) PartialUpdateComposeRecord(ctx context.Context, m *types.Module, onlyColumns []string, rr ...*types.Record) error {
	if len(rr) == 0 {
		return nil
	}

	return Tx(ctx, s.db, s.config, nil, func(db *sqlx.Tx) (err error) {
		for _, res := range rr {
			err = s.ExecUpdateComposeRecords(
				ctx, m,
				squirrel.Eq{s.preprocessColumn("crc.id", ""): s.preprocessValue(res.ID, "")},
				s.ComposeRecordEnc(res).Skip("id").Only(onlyColumns...))
			if err != nil {
				return err
			}
		}

		return nil
	})
}

// PartialUpdateComposeRecordValue updates one or more existing rows in compose_record_value
//
// It wraps the update into transaction and can perform partial update by providing list of updatable columns
//
// @todo this can probably be merged with PartialUpdateComposeRecord
func (s Store) PartialUpdateComposeRecordValue(ctx context.Context, m *types.Module, rr ...*types.RecordValue) error {
	if len(rr) == 0 {
		return nil
	}

	return Tx(ctx, s.db, s.config, nil, func(db *sqlx.Tx) (err error) {
		for _, res := range rr {
			err = s.ExecUpdateComposeRecordValues(
				ctx, m,
				squirrel.Eq{s.preprocessColumn("crv.record_id", ""): s.preprocessValue(res.RecordID, ""),
					s.preprocessColumn("crv.place", ""): s.preprocessValue(res.Place, ""),
					s.preprocessColumn("crv.name", ""):  s.preprocessValue(res.Name, ""),
				},
				s.ComposeRecordValueEnc(res).Skip("record_id", "place", "name"))
			if err != nil {
				return err
			}
		}

		return nil
	})
}

// RemoveComposeRecord removes one or more rows from compose_record table
func (s Store) RemoveComposeRecord(ctx context.Context, m *types.Module, rr ...*types.Record) error {
	if len(rr) == 0 {
		return nil
	}

	return Tx(ctx, s.db, s.config, nil, func(db *sqlx.Tx) (err error) {
		for _, res := range rr {
			err = ExecuteSqlizer(ctx, s.DB(), s.Delete(s.ComposeRecordTable(m, "crc")).Where(squirrel.Eq{s.preprocessColumn("crc.id", ""): s.preprocessValue(res.ID, "")}))
			if err != nil {
				return err
			}
		}

		return nil
	})
}

// RemoveComposeRecordValue removes one or more rows from compose_record_value table
//
// @todo this can probably be merged with RemoveComposeRecord
func (s Store) RemoveComposeRecordValue(ctx context.Context, m *types.Module, rr ...*types.RecordValue) error {
	if len(rr) == 0 {
		return nil
	}

	return Tx(ctx, s.db, s.config, nil, func(db *sqlx.Tx) (err error) {
		for _, res := range rr {
			err = ExecuteSqlizer(ctx, s.DB(), s.Delete(s.ComposeRecordValueTable(m, "crv")).Where(squirrel.Eq{s.preprocessColumn("crv.record_id", ""): s.preprocessValue(res.RecordID, ""),
				s.preprocessColumn("crv.place", ""): s.preprocessValue(res.Place, ""),
				s.preprocessColumn("crv.name", ""):  s.preprocessValue(res.Name, ""),
			}))
			if err != nil {
				return err
			}
		}

		return nil
	})
}

// RemoveComposeRecordByID removes row from the compose_record table
func (s Store) RemoveComposeRecordByID(ctx context.Context, m *types.Module, ID uint64) error {
	return ExecuteSqlizer(ctx, s.DB(), s.Delete(s.ComposeRecordTable(m)).Where(squirrel.Eq{s.preprocessColumn("crc.id", ""): s.preprocessValue(ID, "")}))
}

// RemoveComposeRecordValueByRecordIDPlaceName removes row from the compose_record_value table
//
// @todo this can probably be merged with RemoveComposeRecordByID
func (s Store) RemoveComposeRecordValueByRecordID(ctx context.Context, m *types.Module, recordID uint64, place int, name string) error {
	return ExecuteSqlizer(ctx, s.DB(), s.Delete(s.ComposeRecordValueTable(m)).Where(squirrel.Eq{s.preprocessColumn("crv.record_id", ""): s.preprocessValue(recordID, "")}))
}

// TruncateComposeRecords removes all rows from the compose_record table
func (s Store) TruncateComposeRecords(ctx context.Context, m *types.Module) error {
	return Truncate(ctx, s.DB(), s.ComposeRecordTable(m))
}

// TruncateComposeRecordValues removes all rows from the compose_record_value table
//
// @todo this can probably be merged with TruncateComposeRecords
func (s Store) TruncateComposeRecordValues(ctx context.Context, m *types.Module) error {
	return Truncate(ctx, s.DB(), s.ComposeRecordValueTable(m))
}

// ExecUpdateComposeRecords updates all matchhed (cnd) rows in compose_record with given data
func (s Store) ExecUpdateComposeRecords(ctx context.Context, m *types.Module, cnd squirrel.Sqlizer, set store.Payload) error {
	return ExecuteSqlizer(ctx, s.DB(), s.Update(s.ComposeRecordTable(m, "crc")).Where(cnd).SetMap(set))
}

// ExecUpdateComposeRecordValues updates all matchhed (cnd) rows in compose_record_value with given data
func (s Store) ExecUpdateComposeRecordValues(ctx context.Context, m *types.Module, cnd squirrel.Sqlizer, set store.Payload) error {
	return ExecuteSqlizer(ctx, s.DB(), s.Update(s.ComposeRecordValueTable(m, "crv")).Where(cnd).SetMap(set))
}

// ComposeRecordLookup prepares ComposeRecord query and executes it,
// returning types.Record (or error)
func (s Store) ComposeRecordLookup(ctx context.Context, m *types.Module, cnd squirrel.Sqlizer) (*types.Record, error) {
	return s.scanComposeRecord(s.QueryRow(ctx, s.QueryComposeRecords(m).Where(cnd)))
}

// ComposeRecordValueLookup prepares ComposeRecordValue query and executes it,
// returning types.RecordValue (or error)
func (s Store) ComposeRecordValueLookup(ctx context.Context, m *types.Module, cnd squirrel.Sqlizer) (*types.RecordValue, error) {
	return s.scanComposeRecordValue(s.QueryRow(ctx, s.QueryComposeRecordValues(m).Where(cnd)))
}

func (s Store) scanComposeRecord(row rowScanner, err error) (*types.Record, error) {
	if err != nil {
		return nil, err
	}

	var res = &types.Record{}
	if _, has := s.config.RowScanners["ComposeRecord"]; has {
		scanner := s.config.RowScanners["ComposeRecord"].(func(rowScanner, *types.Record) error)
		err = scanner(row, res)
	} else {
		err = row.Scan(
			&res.ID,
			&res.ModuleID,
			&res.NamespaceID,
			&res.OwnedBy,
			&res.CreatedAt,
			&res.CreatedBy,
			&res.UpdatedAt,
			&res.UpdatedBy,
			&res.DeletedAt,
			&res.DeletedBy,
		)
	}

	if err == sql.ErrNoRows {
		return nil, store.ErrNotFound
	}

	if err != nil {
		return nil, fmt.Errorf("could not scan db row for ComposeRecord: %w", err)
	} else {
		return res, nil
	}
}

func (s Store) scanComposeRecordValue(row rowScanner, err error) (*types.RecordValue, error) {
	if err != nil {
		return nil, err
	}

	var res = &types.RecordValue{}
	if _, has := s.config.RowScanners["ComposeRecordValue"]; has {
		scanner := s.config.RowScanners["ComposeRecordValue"].(func(rowScanner, *types.RecordValue) error)
		err = scanner(row, res)
	} else {
		err = row.Scan(
			&res.RecordID,
			&res.Place,
			&res.Name,
			&res.Ref,
			&res.Value,
			&res.DeletedAt,
		)
	}

	if err == sql.ErrNoRows {
		return nil, store.ErrNotFound
	}

	if err != nil {
		return nil, fmt.Errorf("could not scan db row for ComposeRecordValue: %w", err)
	} else {
		return res, nil
	}
}

// QueryComposeRecords returns squirrel.SelectBuilder with set table and all columns
func (s Store) QueryComposeRecords(m *types.Module) squirrel.SelectBuilder {
	return s.Select(s.ComposeRecordTable(m, "crc"), s.ComposeRecordColumns("crc")...)
}

// ComposeRecordTable name of the db table
func (Store) ComposeRecordTable(m *types.Module, aa ...string) string {
	var alias string
	if len(aa) > 0 {
		alias = " AS " + aa[0]
	}

	return "compose_record" + alias
}

// ComposeRecordColumns returns all defined table columns
//
// With optional string arg, all columns are returned aliased
func (Store) ComposeRecordColumns(aa ...string) []string {
	var alias string
	if len(aa) > 0 {
		alias = aa[0] + "."
	}

	return []string{
		alias + "id",
		alias + "module_id",
		alias + "rel_namespace",
		alias + "owned_by",
		alias + "created_at",
		alias + "created_by",
		alias + "updated_at",
		alias + "updated_by",
		alias + "deleted_at",
		alias + "deleted_by",
	}
}

// ComposeRecordEnc encodes fields from types.Record to store.Payload (map)
func (Store) ComposeRecordEnc(res *types.Record) store.Payload {
	return store.Payload{
		"id":            res.ID,
		"module_id":     res.ModuleID,
		"rel_namespace": res.NamespaceID,
		"owned_by":      res.OwnedBy,
		"created_at":    res.CreatedAt,
		"created_by":    res.CreatedBy,
		"updated_at":    res.UpdatedAt,
		"updated_by":    res.UpdatedBy,
		"deleted_at":    res.DeletedAt,
		"deleted_by":    res.DeletedBy,
	}
}

// QueryComposeRecordValues returns squirrel.SelectBuilder with set table and all columns
func (s Store) QueryComposeRecordValues(m *types.Module) squirrel.SelectBuilder {
	return s.Select(s.ComposeRecordValueTable(m, "crv"), s.ComposeRecordValueColumns("crv")...)
}

// ComposeRecordValueTable name of the db table
func (Store) ComposeRecordValueTable(m *types.Module, aa ...string) string {
	var alias string
	if len(aa) > 0 {
		alias = " AS " + aa[0]
	}

	return "compose_record_value" + alias
}

// ComposeRecordValueColumns returns all defined table columns
//
// With optional string arg, all columns are returned aliased
func (Store) ComposeRecordValueColumns(aa ...string) []string {
	var alias string
	if len(aa) > 0 {
		alias = aa[0] + "."
	}

	return []string{
		alias + "record_id",
		alias + "place",
		alias + "name",
		alias + "ref",
		alias + "value",
		alias + "deleted_at",
	}
}

// ComposeRecordValueEnc encodes fields from types.RecordValue to store.Payload (map)
func (Store) ComposeRecordValueEnc(res *types.RecordValue) store.Payload {
	return store.Payload{
		"record_id":  res.RecordID,
		"place":      res.Place,
		"name":       res.Name,
		"ref":        res.Ref,
		"value":      res.Value,
		"deleted_at": res.DeletedAt,
	}
}

// Checks if field name is "real column", reformats it and returns
func isRealRecordCol(name string) (string, bool) {
	switch name {
	case
		"recordID",
		"id":
		return "crc.id", true
	case
		"module_id",
		"owned_by",
		"created_by",
		"created_at",
		"updated_by",
		"updated_at",
		"deleted_by",
		"deleted_at":
		return "crc." + name, true

	case
		"moduleID",
		"ownedBy",
		"createdBy",
		"createdAt",
		"updatedBy",
		"updatedAt",
		"deletedBy",
		"deletedAt":
		return "crc." + name[0:len(name)-2] + "_" + strings.ToLower(name[len(name)-2:]), true
	}

	return name, false
}
